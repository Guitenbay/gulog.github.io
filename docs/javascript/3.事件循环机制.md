# 事件循环机制  <!-- {docsify-ignore} -->

JavaScript 的事件循环机制是一种异步编程模型，它允许 JavaScript 应用程序在等待 I/O、定时器和其他异步操作完成时，继续执行代码。

事件循环机制由以下主要组件组成：

1. Call Stack（调用栈）：用于存储当前正在执行的函数调用链。当一个函数被调用时，它会被添加到调用栈中，当函数返回时，它会从调用栈中弹出。

2. Heap（堆）：用于存储对象数据。

3. Callback Queue（回调队列）：用于存储待处理的事件回调函数。当一个异步事件被触发时，它会被加入到回调队列中。

4. Event Loop（事件循环）：用于监听调用栈和回调队列，以确定什么时候可以将回调函数添加到调用栈中执行。它的工作原理是不断地检查调用栈是否为空，如果为空，则从回调队列中取出一个回调函数，并添加到调用栈中执行。

事件循环的过程如下：

1. 执行全局代码，将其中的函数调用添加到调用栈中。

2. 当调用栈中没有需要执行的函数时，事件循环会持续监听回调队列和调用栈。

3. 如果回调队列中有待处理的回调函数，事件循环会从队列中取出一个回调函数，并将其添加到调用栈中执行。

4. 当该回调函数执行完毕并返回时，调用栈中的上一个函数会继续执行。

5. 重复上述过程，直到调用栈为空或应用程序被关闭。

需要注意的是，由于 JavaScript 是单线程执行的，因此在执行某个函数的过程中，无法同时执行其他代码。这意味着长时间运行的函数可能会阻塞整个应用程序的进程，因此需要谨慎使用。为了避免出现这种情况，可以考虑使用 Web Workers 或异步函数来实现并发执行。

## 事件循环的执行过程

1. 同步代码，调用栈执行后直接出栈
2. 异步代码，放到 Web API 中，等待时机，等合适的时候放入回调队列（callbackQueue），等到调用栈空时 eventLoop 开始工作，轮询
3. 微任务执行时机比宏任务要早：微任务在DOM渲染前触发，宏任务在DOM渲染后触发

## 微任务和宏任务的根本区别

- 宏任务：setTimeout, setInterval, setImmediate（Node.js）, XHR, DOM 事件
- 微任务：Promise, async/await(Promise 语法糖), fetch(基于Promise), MutationObserver

> 微任务是由 ES6 语法规定的，宏任务是由浏览器规定的

## Vue 里的 nextTick 是微任务还是宏任务？

nextTick 将回调延迟到下次 DOM 更新循环之后执行。
这个特性使得 `nextTick()` 常常被用来处理视图上的更新或者获取最新的 DOM 节点信息等任务。

实际上，nextTick 在 vue 发展的不同版本中，针对各种渲染和 dom 事件问题进行了多次调整。
宏/微任务，甚至两种并行。
在最新版本 2.6.12 中稳定为 微任务。

reference: https://juejin.cn/post/6875492931726376974#
