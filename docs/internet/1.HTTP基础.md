# internet

1. 什么是 internet
2. 什么是 HTTP:
    HTTP 是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。
    是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。

    它是应用层的协议，通过 TCP，或者是 TLS——加密的 TCP 连接来发送

    HTTP 的基本性质：
    - 简单：HTTP 报文能够被人读懂 （虽然下一代 HTTP/2 协议将 HTTP 消息封装到了帧（frame）中，HTTP 大体上还是被设计得简单易读。）
    - 可扩展：在 HTTP/1.0 中出现的 HTTP 标头（header）让协议扩展变得非常容易。
    - 无状态：在同一个连接中，两个执行成功的请求之间是没有关系的。即 HTTP 是无记忆的。
    - 有会话：浏览器无法知道用户的连续操作，但使用 HTTP 的标头扩展，HTTP Cookie 就可以解决这个问题。把 Cookie 添加到标头中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。

3. OSI 七层模型
4. TCP/IP 四层模型

5. HTTP/1.x、2.0 和 QUIC

    1. HTTP/1.0:
        HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。
    2. HTTP/1.1:
        为了减轻这些缺陷，HTTP/1.1 引入了流水线（被证明难以实现）和持久连接的概念：底层的 TCP 连接可以通过 Connection 标头来被部分控制。
    3. HTTP/2.0:
        HTTP/2 则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。

        HTTP 报文（在 HTTP/2 之前）是语义可读的。在 HTTP/2 中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。
    4. QUIC:
        为了更好的适合 HTTP，设计一种更好传输协议的进程一直在进行。Google 就研发了一种以 UDP 为基础，能提供更可靠更高效的传输协议 QUIC

6. HTTP 能控制什么

- 缓存文档如何缓存： 服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。
- 开放同源限制（CORS）：为了防止网络窥听和其他隐私泄漏，浏览器强制对 Web 网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP 可以通过修改标头来开放这样的限制，因此 Web 文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。
- 认证：一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过 HTTP 提供，使用 Authenticate 相似的标头即可，或用 HTTP Cookies 来设置指定的会话。
- 代理和隧道：通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。
- 会话：使用 HTTP Cookie 允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的 HTTP 是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。

7. HTTP 的历史

    1. HTTP/0.9：单行协议

        请求：
        ```
        GET /mypage.html
        ```
        响应：
        ```
        <HTML>
        这是一个非常简单的 HTML 页面
        </HTML>
        ```

    2. HTTP/1.0：构建可扩展性

        请求：有了协议信息、有 HTTP 标头的概念（可扩展）、具备了传输除纯文本 HTML 文件以外其他类型文档的能力（`Content-Type`）
        
        响应：有了状态码，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）、有 HTTP 标头的概念（可扩展）、具备了传输除纯文本 HTML 文件以外其他类型文档的能力（`Content-Type`）

    3. HTTP/1.1：第一个标准化的协议

        HTTP/1.1 消除了大量歧义内容并引入了多项改进：
        - 连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。
        - 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
        - 支持响应分块。
        - 引入额外的缓存控制机制。
        - 引入内容协商机制，包括语言、编码、类型等。并允许客户端和服务器之间约定以最合适的内容进行交换。
        - 凭借 Host 标头，能够使不同域名配置在同一个 IP 地址的服务器上。

    4. 1.1 的扩展：

        - SSL 加密：SSL 在标准化道路上最终成为了 TLS。
        - REST：允许任何 Web 应用程序通过提供 API 以允许查看和修改其数据，而无需更新浏览器或服务器。
        - Server-sent events，服务器可以偶尔推送消息到浏览器。
        - WebSocket，一个新协议，可以通过升级现有 HTTP 协议来建立。
        - 同源策略：跨源资源共享（CORS）和内容安全策略（CSP）规范

    4. HTTP/2.0：更快更优异

        1.1 的问题：HTTP/1.1 链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8 个），带来的成本和复杂性堪忧。比如，HTTP 管线化（pipelining）就成为了 Web 开发的负担。

        HTTP/2 在 HTTP/1.1 有几处基本的不同：

        - HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建。
        - 是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。
        - 压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
        - 允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。

    5. 2.0 的进化

        - 对 Alt-Svc 的支持允许了给定资源的位置和资源鉴定，允许了更智能的 CDN 缓冲机制。
        - 客户端提示（client hint） 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。
        - 在 Cookie 头中引入安全相关的的前缀，帮助保证一个安全的 Cookie 没被更改过。

    5. HTTP/3.0：基于 QUIC 的 HTTP

        QUIC 旨在为 HTTP 连接设计更低的延迟。类似于 HTTP/2，它是一个多路复用协议，但是 HTTP/2 通过单个 TCP 连接运行，所以在 TCP 层处理的数据包丢失检测和重传是会阻止所有流。
        
        QUIC 通过 UDP 运行多个流，并为每个流独立实现数据包丢失检测和重传，因此如果发生错误，只有该数据包中包含数据的流才会被阻止。

8. HTTP方法：OPTIONS POST GET PUT DELETE ...

    1. GET: 只被用于获取数据
    2. HEAD: 与 GET 请求相同的响应，但没有响应体。
    3. POST: 将实体提交到指定的资源.
    4. PUT: 用请求有效载荷替换目标资源的所有当前表示。
    5. DELETE: 删除指定的资源。
    6. CONNECT: 建立一个到由目标资源标识的服务器的隧道。
    7. OPTIONS: 用于描述目标资源的通信选项。

        - 检测服务器所支持的请求方法: 
            ```bash
            curl -X OPTIONS http://example.org -i
            ```
        - CORS 中的预检请求:
            使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。

    8. TRACE
    9. PATCH: 用于对资源应用部分修改。

9. 响应码：100,200,301,302,401,402,403,404,500 ...

    响应被归为以下五大类：

    - 信息响应 (100–199)
    - 成功响应 (200–299)
    - 重定向消息 (300–399)
    - 客户端错误响应 (400–499)
    - 服务端错误响应 (500–599)

    常用响应码：
    
    1. 100 Continue
      
        迄今为止的所有内容都是可行的，客户端应该继续请求

    2. 200 OK
      
        请求成功。

    3. 201 Created
      
        该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。

    4. 202 Accepted

        请求已经接收到，但还未响应，没有结果。预期另外的进程和服务去处理请求，或者批处理。

    5. 204 No Content

        无内容。服务器成功处理，但未返回内容。

    5. 300 Multiple Choice

        请求拥有多个可能的响应。用户代理或者用户应当从中选择一个。

    6. 301 Moved Permanently

        请求资源的 URL 已永久更改。在响应中给出了新的 URL。

    7. 302 Found

        此响应代码表示所请求资源的 URI 已 暂时 更改。未来可能会对 URI 进行进一步的改变。因此，客户机应该在将来的请求中使用这个相同的 URI。

    8. 303 See Other

        服务器发送此响应，以指示客户端通过一个 GET 请求在另一个 URI 中获取所请求的资源。

    9. 304 Not Modified

        用于缓存。它告诉客户端响应和缓存一致，没有被修改，因此客户端可以继续使用相同的缓存版本的响应。

    10. 400 Bad Request

        由于被认为是客户端错误（例如，错误的请求语法、无效的请求消息帧或欺骗性的请求路由），服务器无法或不会处理请求。

    11. 401 Unauthorized

        客户端身份认证未通过，必须对自身进行身份验证才能获得请求的响应。

    12. 403 Forbidden

        客户端没有访问内容的权限；也就是说，它是未经授权的，因此服务器拒绝提供请求的资源。与 `401 Unauthorized` 不同，服务器知道客户端的身份。

    13. 404 Not Found

    14. 405 Method Not Allowed

        服务器知道请求方法，但目标资源不支持该方法。例如，API 可能不允许调用DELETE来删除资源。

    15. 500 Internal Server Error

        服务器遇到了不知道如何处理的情况。

    16. 502 Bad Gateway

        服务器作为网关得到一个错误的响应。

    17. 503 Service Unabailable

        服务器没有准备好处理请求。常见原因是服务器因维护或重载而停机。

    18. 504 Gateway Timeout

        当服务器充当网关且无法及时获得响应时，会给出此错误响应。


10. CORS

    跨源资源共享(CORS)是一种基于 HTTP 头的机制，该机制由服务器告知浏览器允许除了服务器自己以外的其他源（域、协议或端口），使得浏览器允许这些源加载服务器自己的资源。

    可访问场景：
    - 简单请求：form 可以向任何来源提交简单请求

        简单请求定义：

        1. 使用下列方法之一：GET, HEAD, POST
        2. 人为只能设置以下 CORS 安全的字段：
            - Accept
            - Accept-Language
            - Content-Language
            - Content-Type（需要注意额外的限制）
            - Range（只允许简单的范围标头值 如 bytes=256- 或 bytes=127-255）
        3. Content-Type 标头所指定的媒体类型的值仅限于下列三者之一：
            - text/plain
            - multipart/form-data (表单需要传输多媒体资源时)
            - application/x-www-form-urlencoded (表单只传输文本时)
        4. 如果请求是使用 `XMLHttpRequest` 对象发出的，在返回的 `XMLHttpRequest.upload` 对象属性上没有注册任何事件监听器；也就是说，给定一个 `XMLHttpRequest` 实例 `xhr`，没有调用 `xhr.upload.addEventListener()`，以监听该上传请求。
        5. 请求中没有使用 `ReadableStream` 对象。
    - 预检请求

        ```js
        const xhr = new XMLHttpRequest();
        xhr.open('POST', 'https://bar.other/resources/post-here/');
        xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
        xhr.setRequestHeader('Content-Type', 'application/xml');
        xhr.onreadystatechange = handler;
        xhr.send('<person><name>Arun</name></person>');
        ```

        上面的代码使用 POST 请求发送一个 XML 请求体，该请求包含了一个非标准的 HTTP X-PINGOTHER 请求标头。这样的请求标头并不是 HTTP/1.1 的一部分，但通常对于 web 应用很有用处。另外，该请求的 Content-Type 为 application/xml，且使用了自定义的请求标头，所以该请求需要首先发起“预检请求”。

    - 附带身份凭证的请求

        XMLHttpRequest 或 Fetch 与 CORS 的一个有趣的特性是，可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。一般而言，对于跨源 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 对象的某个特殊标志位，或在构造 Request 对象时设置。

10. 基于 HTTP 的 API

    基于 HTTP 的最常用 API 是 `XMLHttpRequest` API，可用于在 user agent 和服务器之间交换数据。现代 Fetch API 提供相同的功能，具有更强大和灵活的功能集。

    另一种 API，即服务器发送的事件，是一种单向服务，允许服务器使用 HTTP 作为传输机制向客户端发送事件。使用 `EventSource` 接口，客户端打开连接并建立事件句柄。客户端浏览器自动将到达 HTTP 流的消息转换为适当的 `Event` 对象，并将它们传递给专门处理这类 `type` 事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给 `onmessage` (en-US) 事件处理程序处理。

