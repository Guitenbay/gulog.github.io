# 布局与重新布局

当渲染器创建并添加到树中时，它没有位置和大小。计算这些值称为布局或回流。

HTML使用基于流的布局模型，这意味着大多数时候可以在一个通道中计算几何图形。
稍后“放入流中”的元素通常不会影响“已经在流中”中的元素的几何形状，
因此布局可以从左到右，从上到下通过文档进行。
> 有例外：例如，HTML table 可能需要多个通道。

布局是一个递归过程。它从根渲染器开始，该渲染器对应于HTML文档的 `<html>` 元素。布局通过递归遍历各层次结构继续，为每个需要的渲染器计算几何信息。

根渲染器的位置是0,0，其尺寸是视口——浏览器窗口的可见部分。

所有渲染器都有一个“布局(layout)”或“回流(reflow)”方法，每个渲染器调用其需要布局的子结构渲染器的布局方法。

## 脏位系统（Dirty bit system ）

为了不为每个小更改做完整的布局，浏览器使用“脏位”系统。更改或添加的渲染器将自身及其子项标记为“dirty”：需要布局。

## 全局布局和增量布局

布局可能在整个渲染树上触发——这是“全局”布局。这可能由于：
1. 影响所有渲染器的全局样式更改，例如字体大小更改。
2. 由于屏幕被调整了大小

布局也可以是增量的，只有脏（dirty）的渲染器才会被重新布局。

当渲染器脏（dirty）时，会触发增量布局（异步）。例如，当额外的内容来自网络并添加到 DOM 树后，新的渲染器被附加到渲染树中时。

## 异步和同步布局

增量布局是异步完成的。Firefox 排队“重排命令”进行增量布局，调度程序异步触发这些命令的批量执行。

请求样式信息时，如“offsetHeight”会**同步**触发增量布局。除此之外，当我们调用 `getComputedStyle` 方法，或者IE里的 `currentStyle` 时，也会**同步**触发增量布局。
原因是为了追求信息的“即时性”和“准确性”。

全局布局通常会同步触发。

> 有时，布局在初始布局后作为回调触发，因为一些属性（如滚动位置）发生了变化。


