# CSS 样式计算

构建渲染树需要计算每个渲染对象的视觉属性。这是通过计算每个元素的样式属性来完成的。

该样式包括各种来源的样式表、内联样式元素和 HTML 中的视觉属性（如“bgcolor”属性）。后者被转换为匹配的 CSS 样式属性。

样式计算带来了一些困难：

1. 样式数据是一个非常大的构造，具有许多样式属性，这可能会导致内存问题。
2. 如果不优化，找到每个元素的匹配规则可能会导致性能问题。遍历每个元素的整个规则列表以找到匹配项是一项艰巨的任务。选择器可能具有复杂的结构，可能导致匹配过程在一条看似有前途的道路上开始，这条道路被证明是徒劳的，必须尝试另一条道路。

   例如-此 CSS 选择器：

   ```css
   div div div div {
     ...;
   }
   ```

   表示规则适用于作为 3 个 div 的后代的 `<div>`。假设你想检查该规则是否适用于给定的`<div>` 元素，那么可能需要遍历节点树，才能发现最多只有两个 div，且该规则并不适用。

3. 应用规则涉及相当复杂的级联规则，这些规则定义了规则的层次结构。

## Firefox 规则树

Firefox 有两个额外的树，以便于样式计算：规则树和样式上下文树。WebKit 也有样式对象，但它们不存储在像样式上下文树这样的树中，只有 DOM 节点指向其相关样式。

所有匹配的规则都存储在树中。路径中的底部节点具有更高的优先级。该树包含找到的规则匹配的所有路径。

这个想法是将树路径视为词典中的单词。假设我们已经计算了这个规则树：

![计算规则树](https://web-dev.imgix.net/image/T4FyVKpzu4WKF1kBNvXepbi08t52/RwZNIJLCLZqbH2c9eXXg.png?auto=format&w=800)

假设我们需要匹配内容树中另一个元素的规则，并找出匹配的规则（按正确的顺序）是 B-E-I。我们在树中已经有了这条路径，因为我们已经计算过路径 A-B-E-I-L。我们现在要做的工作会更少。

## 以正确的级联顺序应用规则

CSS 书写的是样式规则。有时你可能创建两个应用于同一个元素的规则。为解决在发生冲突的时候应该使用哪条规则，CSS 具有**层叠**和**优先级**的概念。

这里也有**继承**的概念，也就是在默认情况下，一些 css 属性继承当前元素的父元素上设置的值，有些则不继承。这也可能导致一些和期望不同的结果。

1. 层叠：样式表层叠——简单的说，就是 CSS 规则的顺序很重要；当应用两条**同级别**的规则到一个元素的时候，**写在后面**的就是实际使用的规则。
2. 优先级：浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度。（越具体的规则越优先，下文具体介绍优先级）
3. 继承：继承也需要在上下文中去理解——一些设置在父元素上的 CSS 属性（如：color, font-family）是可以被子元素继承的，有些（如：width）则不能。

层叠定义应用哪一个规则的因素（根据重要性排序如下，后面的更重要）：

1. 资源顺序：后面的规则覆盖前面的规则。
2. 优先级：选用优先级高的规则。
3. 内联样式：即 style 属性内的样式声明，优先于所有普通的样式，无论其优先级如何。
4. 重要程度：`!important` 覆盖上面的所有规则。

### CSS 选择器

基本选择器：

1. 通配选择器：一个星号 (\*) 就是一个通配选择器。它可以匹配任意类型的 HTML 元素。

   用例：

   - `ns|*` - 会匹配 ns 命名空间下的所有元素
   - `*|*` - 会匹配所有命名空间下的所有元素
   - `|*` - 会匹配所有没有命名空间的元素

2. 元素选择器：按照给定的节点名称，选择所有匹配的元素。

   用例：`input` 匹配任何 `<input>` 元素。

3. 类选择器

   用例：`.index` 匹配任何 `class` 属性中含有 "index" 类的元素。

4. ID 选择器：按照 id 属性选择一个与之匹配的元素。每个 ID 属性都应当是唯一的。

   用例：`#toc` 匹配 ID 为 "toc" 的元素。

5. 属性选择器：按照给定的属性，选择所有匹配的元素。

   语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value]

   用例：[autoplay] 选择所有具有 autoplay 属性的元素（不论这个属性的值是什么）。

分组选择器

1. 选择器列表：`,` 是将不同的选择器组合在一起的方法，它选择所有能被列表中的任意一个选择器选中的节点。

   示例：`div, span` 会同时匹配 `<span>` 元素和 `<div>` 元素。

组合器

1. 后代组合器：`div span` 匹配所有位于任意 `<div>` 元素之内的 `<span>` 元素。
2. 直接后代组合器：`ul > li` 匹配**直接**嵌套在 `<ul>` 元素内的所有 `<li>` 元素。
3. 一般兄弟组合器：`p ~ span` 匹配同一父元素下，`<p>` 元素后的所有 `<span>` 元素。
4. 紧邻兄弟组合器: `h2 + p` 会匹配紧邻在 `h2` 元素后的第一个 `<p>` 元素。

伪选择器

1. 伪类：`:` 伪选择器支持按照未被包含在文档树中的**状态信息**来选择元素。

   用法：`a:visited` 匹配所有曾被访问过的 `<a>` 元素。

2. 伪元素: `::` 伪选择器用于表示无法用 HTML 语义表达的**实体**。

   用法：`p::first-line` 匹配所有 `<p>` 元素的第一行。

### 优先级的权重计算

一个选择器的优先级可以说是由三个不同的值（或分量）相加，可以认为是百（ID）十（类）个（元素）——三位数的三个位数：

1. ID：选择器中包含 ID 选择器则百位得一分。（例如，`#example`）
2. 类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。（例如，`.example`, `[type="radio"]`, `:hover`）
3. 元素：选择器中包含元素、伪元素选择器则个位得一分。（例如，`h1`, `::before`）

> 通配选择符（universal selector）（\*）关系选择符（combinators）（+, >, ~, " ", ||）和 否定（:not()）和任意匹配（:is()）对优先级没有影响。（但是，在 :not() 和 :is() 内部声明的选择器会影响优先级。内部声明的选择器中，对优先级算法有贡献的参数的优先级的**最大值**将作为该伪类选择器的优先级）。

例子：

| 选择器                                    | ID  | 类  | 元素 | 优先级 |
| :---------------------------------------- | :-- | :-- | :--- | :----- |
| `h1`                                      | 0   | 0   | 1    | 0-0-1  |
| `h1 + p::first-letter`                    | 0   | 0   | 3    | 0-0-3  |
| `li > a[href*="en-US"] > .inline-warning` | 0   | 2   | 2    | 0-2-2  |
| `#identifier`                             | 1   | 0   | 0    | 1-0-0  |
| `button:not(#mainBtn, .cta)`              | 1   | 0   | 1    | 1-0-1  |
